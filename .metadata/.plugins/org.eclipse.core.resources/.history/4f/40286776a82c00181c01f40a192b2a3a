package reversi;

import java.util.*;

import javax.swing.JFrame;

class State {
    char[] board;

    public State(char[] arr) {
        this.board = Arrays.copyOf(arr, arr.length);
    }

    public int getScore() {

        // TO DO: return game theoretic value of the board
    	int dark = 0;
    	int light = 0;
    	for (int i = 0; i < board.length; i++) {
    		if (board[i] == 1) {
    			dark++;
    		} else if (board[i] == 2) {
    			light++;
    		}
    	}
    	if (dark > light) {
    		return 1;
    	} else if (light > dark) {
    		return -1;
    	} else {
    		return 0;
    	}
    }
    
    public boolean isTerminal() {
    	
        // TO DO: determine if the board is a terminal node or not and return boolean
    	boolean isTerminal;
    	if (getSuccessors('1') == null && getSuccessors('2') == null) {
    		isTerminal = true;
    		System.out.println(getScore());
    	} else {
    		isTerminal = false;
    		System.out.println("non-terminal");
    	}
        return isTerminal;
    }

    public State[] getSuccessors(char player) {

        // TO DO: get all successors and return them in proper order
    	int numSuccessors = 0;
    	char enemy;
    	if (player == '1') {
    		enemy = '2';
    	} else {
    		enemy = '1';
    	}
    	int[][] directions = new int[][] {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};
    	State[] successors = new State[14], successors2 = null;
    	for (int i = 0; i < this.board.length; i++) {
    		if (this.board[i] == 0) {
    			int x = i % 4;
    			int y = i / 4;
    			int horizontal[] = new int[4];
    			int h = 0;
    			int vertical[] = new int[4];
    			int v = 0;
    			int diagonalR[] = new int[4];
    			int dr = 0;
    			int diagonalL[] = new int[4];
    			int dl = 0;
    			//horizontal check
    			for (int j = -3; j < 3; j++) {
    				int nx = x + j;
    				if (nx < 0 || nx > 3) {
    					continue;
    				}
    				int check = nx + 4*y;
    				horizontal[h] = this.board[check];
    				h++;    				
    			}
    			//vertical check
    			for (int j = -3; j < 3; j++) {
    				int ny = y + j;
    				if (ny < 0 || ny > 3 || ny == x) {
    					continue;
    				}
    				int check = x + 4*ny;
    			}
    			//down-right diagonal check
    			for (int j = -3; j < 3; j++) {
	
    			}
    			//down-left diagonal check
    			for (int j = -3; j < 3; j++) {
	
    			}	
  		}
    	}
    	
    	successors2 = new State[numSuccessors];
    	for(int i = 0; i < numSuccessors; i++) {
    		successors2[i]	= successors[i];
    	}
    	
    	
    	
    	
        return successors2;
    }
 
    public void printState(int option, char player) {

        // TO DO: print a State based on option (flag)

    }

    public String getBoard() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 16; i++) {
            builder.append(this.board[i]);
        }
        return builder.toString().trim();
    }

    public boolean equals(State src) {
        for (int i = 0; i < 16; i++) {
            if (this.board[i] != src.board[i])
                return false;
        }
        return true;
    }
}

class Minimax {
	static int count = 0;
	
	private static int max_value(State curr_state) {
		
        // TO DO: implement Max-Value of the Minimax algorithm
		count++;
		if (curr_state.isTerminal()) {
			return curr_state.getScore();
		}
		int a = -999;
		for (State s : curr_state.getSuccessors('1')) {
			int k = min_value(s);
			if (k > a) a = k;			
		}
		return a;
	}
	
	private static int min_value(State curr_state) {
		
        // TO DO: implement Min-Value of the Minimax algorithm
		count++;
		if (curr_state.isTerminal()) {
			return curr_state.getScore();
		}
		int b = 999;
		for (State s : curr_state.getSuccessors('2')) {
			int k = max_value(s);
			if (k < b) b = k;			
		}
		return b;
	}
	
	private static int max_value_with_pruning(State curr_state, int alpha, int beta) {
	    
        // TO DO: implement Max-Value of the alpha-beta pruning algorithm

	}
	
	private static int min_value_with_pruning(State curr_state, int alpha, int beta) {
	    
        // TO DO: implement Min-Value of the alpha-beta pruning algorithm

	}
	
	public static int run(State curr_state, char player) {

        // TO DO: run the Minimax algorithm and return the game theoretic value

	}
	
	public static int run_with_pruning(State curr_state, char player) {
	    
        // TO DO: run the alpha-beta pruning algorithm and return the game theoretic value

	}
}

public class Reversi {
    public static void main(String args[]) {
        if (args.length != 3) {
            System.out.println("Invalid Number of Input Arguments");
            return;
        }
        int flag = Integer.valueOf(args[0]);
        char[] board = new char[16];
        for (int i = 0; i < 16; i++) {
            board[i] = args[2].charAt(i);
        }
        int option = flag / 100;
        char player = args[1].charAt(0);
        if ((player != '1' && player != '2') || args[1].length() != 1) {
            System.out.println("Invalid Player Input");
            return;
        }
        State init = new State(board);
        init.printState(option, player);
    }
}

